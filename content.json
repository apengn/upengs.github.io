{"meta":{"title":"Peng","subtitle":"Welcome to my Blogs!","description":null,"author":"pengemailcom@163.com","url":"https://upengs.github.io","root":"/"},"pages":[{"title":"","date":"2019-07-20T04:03:17.304Z","updated":"2019-07-20T04:03:17.304Z","comments":true,"path":"content.json","permalink":"https://upengs.github.io/content.json","excerpt":"","text":"{}"},{"title":"404 Not Found：该页无法显示","date":"2019-07-20T04:02:24.536Z","updated":"2019-07-20T04:02:24.536Z","comments":false,"path":"/404.html","permalink":"https://upengs.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-02T07:33:18.173Z","updated":"2019-07-02T07:33:18.172Z","comments":false,"path":"about/index.html","permalink":"https://upengs.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-07-02T09:17:12.056Z","updated":"2019-07-02T09:17:12.056Z","comments":false,"path":"books/index.html","permalink":"https://upengs.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-02T07:33:18.173Z","updated":"2019-07-02T07:33:18.172Z","comments":false,"path":"categories/index.html","permalink":"https://upengs.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-07-02T07:33:18.173Z","updated":"2019-07-02T07:33:18.172Z","comments":true,"path":"links/index.html","permalink":"https://upengs.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-07-02T07:33:18.173Z","updated":"2019-07-02T07:33:18.172Z","comments":false,"path":"repository/index.html","permalink":"https://upengs.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-02T07:33:18.173Z","updated":"2019-07-02T07:33:18.172Z","comments":false,"path":"tags/index.html","permalink":"https://upengs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通过kubernetes将数据注入应用程序","slug":"Define-a-Command-and-Arguments-for-a-Container","date":"2019-08-03T04:08:53.000Z","updated":"2019-08-03T10:16:01.735Z","comments":true,"path":"2019/08/03/Define-a-Command-and-Arguments-for-a-Container/","link":"","permalink":"https://upengs.github.io/2019/08/03/Define-a-Command-and-Arguments-for-a-Container/","excerpt":"","text":"定义容器的命令和参数创建Pod时，可以为Pod中运行的容器定义命令和参数。要定义命令，请command 在配置文件中包含该字段。要定义命令的参数，请args在配置文件中包含该字段。创建Pod后，无法更改您定义的命令和参数12345678910111213apiVersion: v1kind: Podmetadata: name: command-demo labels: purpose: demonstrate-commandspec: containers: - name: command-demo-container image: debian command: [\"printenv\"] args: [\"HOSTNAME\", \"KUBERNETES_PORT\"] restartPolicy: OnFailure 使用环境变量来定义参数12345env:- name: MESSAGE value: \"hello world\"command: [\"/bin/echo\"]args: [\"$(MESSAGE)\"] 在shell中运行命令12command: [\"/bin/sh\"]args: [\"-c\", \"while true; do echo hello; sleep 10;done\"] 此表总结了Docker和Kubernetes使用的字段名称。 描述 Docker字段名称 Kubernetes字段名称 该命令由容器运行 ENTRYPONT command 传递给命令的参数 CMD args 当您覆盖默认的Entrypoint和Cmd时，这些规则适用： 如果您不提供Container command或args使用Container，则使用Docker镜像中定义的默认值。 如果为Container提供command但不args提供，则仅使用提供 command的。默认的EntryPoint和Docker镜像中定义的默认Cmd将被忽略。 如果仅为argsContainer提供，则Docker镜像中定义的默认入口点将与args您提供的一起运行。 如果提供command和args，则默认的入口点和Docker镜像中定义的默认Cmd将被忽略。你command和你一起跑 args。 定义容器的环境变量创建Pod时，可以为Pod中运行的容器设置环境变量。要设置环境变量，请在配置文件中包含env或 envFrom字段。 在本练习中，您将创建一个运行一个容器的Pod。Pod的配置文件定义了一个具有名称DEMO_GREETING和值的环境变量”Hello from the environment”。这是Pod的配置文件：123456789101112131415apiVersion: v1kind: Podmetadata: name: envar-demo labels: purpose: demonstrate-envarsspec: containers: - name: envar-demo-container image: gcr.io/google-samples/node-hello:1.0 env: - name: DEMO_GREETING value: \"Hello from the environment\" - name: DEMO_FAREWELL value: \"Such a sweet sorrow\" 在配置中使用环境变量1234567891011121314151617apiVersion: v1kind: Podmetadata: name: print-greetingspec: containers: - name: env-print-demo image: bash env: - name: GREETING value: \"Warm greetings to\" - name: HONORIFIC value: \"The Most Honorable\" - name: NAME value: \"Kubernetes\" command: [\"echo\"] args: [\"$(GREETING) $(HONORIFIC) $(NAME)\"] 通过环境变量将Pod信息暴露给容器有两种方法可以将Pod和Container字段公开给正在运行的Container：1、环境变量 2、DownwardAPIVolumeFiles 这两种暴露Pod和Container字段的方式一起称为 Downward API。 参考：1234567891011121314151617181920212223242526272829303132333435363738apiVersion: v1kind: Podmetadata: name: dapi-envars-fieldrefspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"sh\", \"-c\"] args: - while true; do echo -en '\\n'; printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE; printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT; sleep 10; done; env: - name: MY_NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: MY_POD_IP valueFrom: fieldRef: fieldPath: status.podIP - name: MY_POD_SERVICE_ACCOUNT valueFrom: fieldRef: fieldPath: spec.serviceAccountName restartPolicy: Never 通过文件mount的形式将pod 信息暴露给container1234567891011121314151617181920212223242526272829303132333435363738apiVersion: v1kind: Podmetadata: name: kubernetes-downwardapi-volume-example labels: zone: us-est-coast cluster: test-cluster1 rack: rack-22 annotations: build: two builder: john-doespec: containers: - name: client-container image: k8s.gcr.io/busybox command: [\"sh\", \"-c\"] args: - while true; do if [[ -e /etc/podinfo/labels ]]; then echo -en '\\n\\n'; cat /etc/podinfo/labels; fi; if [[ -e /etc/podinfo/annotations ]]; then echo -en '\\n\\n'; cat /etc/podinfo/annotations; fi; sleep 5; done; volumeMounts: - name: podinfo mountPath: /etc/podinfo readOnly: false volumes: - name: podinfo downwardAPI: items: - path: \"labels\" fieldRef: fieldPath: metadata.labels - path: \"annotations\" fieldRef: fieldPath: metadata.annotations 使用secrets安全地注入数据到container1kubectl create secret generic my-secret --from-literal=username=username --from-literal=password=12345 123456789apiVersion: v1data: password: MTIzNDU= username: dXNlcm5hbWU=kind: Secretmetadata: name: my-secret namespace: defaulttype: Opaque 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: secret-test-podspec: containers: - name: test-container image: nginx volumeMounts: # name must match the volume name below - name: secret-volume mountPath: /etc/secret-volume # The secret data is exposed to Containers in the Pod through a Volume. volumes: - name: secret-volume secret: secretName: my-secret 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: envvars-multiple-secretsspec: containers: - name: envars-test-container image: nginx env: - name: DB_PASSWORD valueFrom: secretKeyRef: name: my-secret key: password - name: DB_USERNAME valueFrom: secretKeyRef: name: my-secret key: username 1234567891011apiVersion: v1kind: Podmetadata: name: envvars-multiple-secretsspec: containers: - name: envars-test-container image: nginx envFrom: secretRef: name: my-secret 参考：https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/ 使用PodPreset将信息注入Pod参考：https://kubernetes.io/docs/tasks/inject-data-application/podpreset/","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://upengs.github.io/tags/kubernetes/"}]},{"title":"使用Kubernetes API访问群集","slug":"Access-Clusters-Using-the-Kubernetes-API","date":"2019-08-03T02:32:31.000Z","updated":"2019-08-03T02:57:52.530Z","comments":true,"path":"2019/08/03/Access-Clusters-Using-the-Kubernetes-API/","link":"","permalink":"https://upengs.github.io/2019/08/03/Access-Clusters-Using-the-Kubernetes-API/","excerpt":"","text":"使用kubectl proxy1kubectl proxy --port 8080 &amp; 1curl http://localhost:8080/api 输出类似于123456789101112&#123; &quot;kind&quot;: &quot;APIVersions&quot;, &quot;versions&quot;: [ &quot;v1&quot; ], &quot;serverAddressByClientCIDRs&quot;: [ &#123; &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;, &quot;serverAddress&quot;: &quot;192.168.1.191:6443&quot; &#125; ]&#125; 不通过kubectl proxy通过将身份验证令牌直接传递给API服务器，可以避免使用kubectl代理，如下所示 使用grep/cut方法：1kubectl config view -o jsonpath='&#123;\"Cluster name\\tServer\\n\"&#125;&#123;range .clusters[*]&#125;&#123;.name&#125;&#123;\"\\t\"&#125;&#123;.cluster.server&#125;&#123;\"\\n\"&#125;&#123;end&#125;' 输出12Cluster name Serverkubernetes https://dev-7:6443 12345678910export CLUSTER_NAME=\"kubernetes\"export APISERVER=$(kubectl config view -o jsonpath=\"&#123;.clusters[?(@.name==\\\"$&#123;CLUSTER_NAME&#125;\\\")].cluster.server&#125;\")# Gets the token value## linuxexport TOKEN=$(kubectl get secrets -o jsonpath=\"&#123;.items[?(@.metadata.annotations['kubernetes\\.io/service-account\\.name']=='default')].data.token&#125;\"|base64 -d)## macexport TOKEN=$(kubectl get secrets -o jsonpath=\"&#123;.items[?(@.metadata.annotations['kubernetes\\.io/service-account\\.name']=='default')].data.token&#125;\"|base64 -D)curl -X GET $&#123;APISERVER&#125;/api --header \"Authorization: Bearer $&#123;TOKEN&#125;\" --insecure 使用jsonpath方法：123export APISERVER=$(kubectl config view --minify -o jsonpath='&#123;.clusters[0].cluster.server&#125;')export TOKEN=$(kubectl get secret $(kubectl get serviceaccount default -o jsonpath='&#123;.secrets[0].name&#125;') -o jsonpath='&#123;.data.token&#125;' | base64 --decode )curl $&#123;APISERVER&#125;/api --header \"Authorization: Bearer $&#123;TOKEN&#125;\" --insecure 使用client-go编程的方式来访问参考:https://github.com/kubernetes/client-go123456789101112131415import ( \"fmt\" \"k8s.io/client-go/1.4/kubernetes\" \"k8s.io/client-go/1.4/pkg/api/v1\" \"k8s.io/client-go/1.4/tools/clientcmd\")... // uses the current context in kubeconfig config, _ := clientcmd.BuildConfigFromFlags(\"\", \"path to kubeconfig\") // creates the clientset clientset, _:= kubernetes.NewForConfig(config) // access the API to list pods pods, _:= clientset.CoreV1().Pods(\"\").List(v1.ListOptions&#123;&#125;) fmt.Printf(\"There are %d pods in the cluster\\n\", len(pods.Items))... 参考： https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://upengs.github.io/tags/kubernetes/"}]},{"title":"dockerfile编写文档","slug":"dockerfile","date":"2019-07-20T03:21:52.000Z","updated":"2019-07-20T03:25:54.584Z","comments":true,"path":"2019/07/20/dockerfile/","link":"","permalink":"https://upengs.github.io/2019/07/20/dockerfile/","excerpt":"","text":"https://docs.docker.com/engine/reference/builder/","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://upengs.github.io/tags/docker/"}]},{"title":"Tmux常用快捷键以及我会常到的一些问题汇总","slug":"tmux","date":"2019-07-20T02:45:53.000Z","updated":"2019-07-20T03:06:30.508Z","comments":true,"path":"2019/07/20/tmux/","link":"","permalink":"https://upengs.github.io/2019/07/20/tmux/","excerpt":"","text":"参考链接：https://www.cnblogs.com/piperck/p/4992159.htmlhttps://www.cnblogs.com/ifantastic/p/4647523.html","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://upengs.github.io/tags/linux/"}]},{"title":"makefile相关资料","slug":"makefile","date":"2019-07-19T07:45:18.000Z","updated":"2019-07-19T07:47:00.732Z","comments":true,"path":"2019/07/19/makefile/","link":"","permalink":"https://upengs.github.io/2019/07/19/makefile/","excerpt":"","text":"Makefile旅行http://makefiletutorial.com/","categories":[],"tags":[{"name":"makefile","slug":"makefile","permalink":"https://upengs.github.io/tags/makefile/"}]},{"title":"golang中的格式化输入输出","slug":"golang占位符","date":"2019-07-19T07:23:02.000Z","updated":"2019-07-19T07:24:44.927Z","comments":true,"path":"2019/07/19/golang占位符/","link":"","permalink":"https://upengs.github.io/2019/07/19/golang占位符/","excerpt":"","text":"简介】 fmt 包实现了格式化 I/O 函数，类似于 C 的 printf 和 scanf。格式“占位符”衍生自 C，但比 C 更简单。 【打印】 占位符： [一般] %v 相应值的默认格式。在打印结构体时，“加号”标记（%+v）会添加字段名 %#v 相应值的 Go 语法表示 %T 相应值的类型的 Go 语法表示 %% 字面上的百分号，并非值的占位符 [布尔] %t 单词 true 或 false。 [整数] %b 二进制表示 %c 相应 Unicode 码点所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号围绕的字符字面值，由 Go 语法安全地转义 %x 十六进制表示，字母形式为小写 a-f %X 十六进制表示，字母形式为大写 A-F %U Unicode 格式：U+1234，等同于 “U+%04X” [浮点数及其复合构成] %b 无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 %E 科学计数法，例如 -1234.456E+78 %f 有小数点而无指数，例如 123.456 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的 0）输出 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的 0）输出 [字符串与字节切片] %s 字符串或切片的无解译字节 %q 双引号围绕的字符串，由 Go 语法安全地转义 %x 十六进制，小写字母，每字节两个字符 %X 十六进制，大写字母，每字节两个字符 [指针] %p 十六进制表示，前缀 0x [注意] 这里没有 ‘u’ 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地， 这里也不需要指定操作数的大小（int8，int64）。 宽度与精度的控制格式以 Unicode 码点为单位。（这点与 C 的 printf 不同， 它以字节数为单位。）二者或其中之一均可用字符 ‘*’ 表示， 此时它们的值会从下一个操作数中获取，该操作数的类型必须为 int。 // 宽度与精度的控制以 Unicode 码点为单位fmt.Printf(“\\”%8s\\”\\n”, “123456”) // 最大长度为 8// “ 123456”fmt.Printf(“\\”%8s\\”\\n”, “你好”) // 最大长度为 8// “ 你好” // 宽度与精度均可用字符 ‘‘ 表示fmt.Printf(“%0.*f \\n”, 8, 3, 13.25) // 总长度 8，小数位数 3fmt.Printf(“%08.3f \\n”, 13.25) // 总长度 8，小数位数 3// 0013.250 对数值而言，宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。 但对于 %g/%G 而言，精度为所有数字的总数。例如，对于 123.45，格式 %6.2f 会打印 123.45，而 %.4g 会打印 123.5。%e 和 %f 的默认精度为 6；但对于 %g 而言，它的默认精度为确定该值所必须的最小位数。 对大多数值而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。对字符串而言，精度为输出的最大字符数，如果必要的话会直接截断。 // 宽度与精度标记字符串fmt.Printf(“%8q”, “ABC”) // 最小长度为 8（包括 %q 的引号字符）// “ABC”fmt.Printf(“%.8q”, “1234567890”) // 最大长度为 8（不包括 %q 的引号字符）// “12345678” [其它标记] + 总打印数值的正负号；对于 %q（%+q）保证只输出 ASCII 编码的字符。 - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o），为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；如果可能的话，%q（%#q）会打印原始（即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 ‘x’）。 ‘ ‘ （空格）为数值中省略的正负号留出空白（% d）；以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开： fmt.Printf(“% x\\n”, “Hello”)// 48 65 6c 6c 6f 0 填充前导的 0 而非空格；对于数字，这会将填充移到正负号之后 [注意] 标记有时会被占位符忽略，所以不要指望它们。例如十进制没有备用格式，因此 %#d 与 %d 的行为相同。 对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化， 它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白， 并在末尾追加一个换行符。 不考虑占位符的话，如果操作数是接口值，就会使用其内部的具体值，而非接口本身。 因此： var i interface{} = 23fmt.Printf(“%v\\n”, i)// 会打印 23 若一个操作数实现了 Formatter 接口，该接口就能更好地用于控制格式化。 若其格式（它对于 Println 等函数是隐式的 %v）对于字符串是有效的（%s %q %v %x %X），以下两条规则也适用： 1、若一个操作数实现了 error 接口，Error 方法就能将该对象转换为字符串，随后会根据占位符的需要进行格式化。 2、若一个操作数实现了 String() string 方法，该方法能将该对象转换为字符串，随后会根据占位符的需要进行格式化。 为避免以下这类递归的情况： type X string func (x X) String() string { return Sprintf(“&lt;%s&gt;”, x) } 需要在递归前转换该值： func (x X) String() string { return Sprintf(“&lt;%s&gt;”, string(x)) } [格式化错误] 如果给占位符提供了无效的实参（例如将一个字符串提供给 %d），所生成的字符串会包含该问题的描述，如下例所示： 类型错误或占位符未知：%!verb(type=value) Printf(“%d”, hi)// %!d(string=hi) 实参太多：%!(EXTRA type=value) Printf(“hi”, “guys”)// hi%!(EXTRA string=guys) 实参太少：%!verb(MISSING) Printf(“hi%d”)// hi %!d(MISSING) 宽度或精度不是 int 类型：%!(BADWIDTH）或 %!(BADPREC) Printf(“%*s”, 4.5, “hi”)// %!(BADWIDTH)hi Printf(“%.*s”, 4.5, “hi”)// %!(BADPREC)hi 所有错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。 【扫描】 一组类似的函数通过扫描已格式化的文本来产生值。Scan、Scanf 和 Scanln 从 os.Stdin 中读取；Fscan、Fscanf 和 Fscanln 从指定的 io.Reader 中读取； Sscan、Sscanf 和 Sscanln 从实参字符串中读取。Scanln、Fscanln 和 Sscanln 在换行符处停止扫描，且需要条目紧随换行符之后；Scanf、Fscanf 和 Sscanf 需要输入换行符来匹配格式中的换行符；其它函数则将换行符视为空格。 Scanf、Fscanf 和 Sscanf 根据格式字符串解析实参，类似于 Printf。例如，%x 会将一个整数扫描为十六进制数，而 %v 则会扫描该值的默认表现格式。 格式化行为类似于 Printf，但也有如下例外： %p 没有实现 %T 没有实现 %e %E %f %F %g %G 都完全等价，且可扫描任何浮点数或复合数值 %s 和 %v 在扫描字符串时会将其中的空格作为分隔符 标记 # 和 + 没有实现 在使用 %v 占位符扫描整数时，可接受友好的进制前缀 0（八进制）和 0x（十六进制）。 宽度被解释为输入的文本（%5s 意为最多从输入中读取 5 个符文来扫描成字符串），而扫描函数则没有精度的语法（没有 %5.2f，只有 %5f）。 当以某种格式进行扫描时，无论在格式中还是在输入中，所有非空的连续空白字符 （除换行符外）都等价于单个空格。由于这种限制，格式字符串文本必须匹配输入的文本，如果不匹配，扫描过程就会停止，并返回已扫描的实参数。 在所有的扫描参数中，若一个操作数实现了 Scan 方法（即它实现了 Scanner 接口），该操作数将使用该方法扫描其文本。此外，若已扫描的实参数少于所提供的实参数，就会返回一个错误。 所有需要被扫描的实参都必须是基本类型或实现了 Scanner 接口的类型。 注意：Fscan 等函数会从输入中多读取一个字符（符文），因此，如果循环调用扫描函数，可能会跳过输入中的某些数据。一般只有在输入的数据中没有空白符时该问题才会出现。若提供给 Fscan 的读取器实现了 ReadRune，就会用该方法读取字符。若此读取器还实现了 UnreadRune 方法，就会用该方法保存字符，而连续的调用将不会丢失数据。若要为没有 ReadRune 和 UnreadRune 方法的读取器加上这些功能，需使用 bufio.NewReader。 转载：https://blog.csdn.net/xiaoyida11/article/details/51554022","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://upengs.github.io/tags/golang/"}]},{"title":"kubernetes 创建 pvc-pv","slug":"pvc-pv","date":"2019-07-02T02:18:31.000Z","updated":"2019-07-02T13:04:58.560Z","comments":true,"path":"2019/07/02/pvc-pv/","link":"","permalink":"https://upengs.github.io/2019/07/02/pvc-pv/","excerpt":"","text":"pv.yaml12345678910111213apiVersion: v1kind: PersistentVolumemetadata: name: pv0003spec: capacity: storage: 5Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle nfs: path: /k8s/weblogic server: 192.168.0.103 pvc.yaml12345678910kind: PersistentVolumeClaimapiVersion: v1metadata: name: weblogiclogsspec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi 创建1kubectl apply -f pv.yaml -f pvc.yaml 查看创建之后的,发现pv已经被bound1234567kubectl get pvNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM pv0003 5Gi RWO Recycle Bound default/weblogiclogskubectl get pvcNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGEweblogiclogs Bound pv0003 5Gi RWO 9m","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://upengs.github.io/tags/kubernetes/"}]},{"title":"golang相关资料","slug":"golang","date":"2019-06-28T06:47:23.000Z","updated":"2019-07-28T13:22:40.589Z","comments":true,"path":"2019/06/28/golang/","link":"","permalink":"https://upengs.github.io/2019/06/28/golang/","excerpt":"","text":"##Go语言高级编程(Advanced Go Programming)https://chai2010.cn/advanced-go-programming-book/https://github.com/golang/go/wiki golang 官方编码规范https://github.com/golang/go/wiki/CodeReviewCommentshttps://golang.org/doc/effective_go.html golang 同步原语与锁 https://draveness.me/golang/concurrency/golang-sync-primitives.html Go内存分配那些事，就这么简单！https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw https://github.com/WilburXu/blog/blob/master/Golang/Go%20%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.md 大量的数据使用gobhttps://blog.golang.org/gobs-of-data","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://upengs.github.io/tags/golang/"}]},{"title":"Kubernetes中的Admission Controller webhook","slug":"webhook","date":"2019-06-28T06:39:47.000Z","updated":"2019-07-03T08:28:45.425Z","comments":true,"path":"2019/06/28/webhook/","link":"","permalink":"https://upengs.github.io/2019/06/28/webhook/","excerpt":"","text":"Kubernetes中的Admission Controller是做什么的呢？有什么用呢？怎么自己定义一个呢？Q: 什么是Admission Controller?A: 官方定义： An admission controller is a piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object, but after the request is authenticated and authorized. 我理解的： Admission Controller是一个拦截器拦截发送给Kuberenetes API Server的请求什么时候拦截？在请求通过认证之后，请求被存储起来之前 所以顺理成章，由于拦截的是发送给API Server的请求，所以Admission Controller存在于API Server内部，即compiled into the kube-apiserver binary（被编译进API Server的可执行文件里）。kubernetes将AC分为三种： validating，验证型。用于验证k8s的资源定义是否符合规则mutating，修改型。用于修改k8s的资源定义，比如加个label什么的二者皆是，即同一个AC，既是验证型又是修改型 多个Admission Controller会形成一个Admission Chain（链条），修改型的在前面先执行，验证型的在后面后执行，这样验证型的才能去验证修改的对不对。K: interceptor, validating, mutating, Admission ChainQ: Admission Controller有什么用？A: API Server内置了一些AC，有各种各样的作用[1]。比如： EventRateLimit，用于限制事件的频率LimitRanger，验证所有的请求都没有超出namespace中定义的LimitRange 还有很多其他AC，具体请参考Kubernetes文档。这些AC中，有两个对用户来说比较有用： MutatingAdmissionWebhook，这是一个webhook，即网络钩子，也就是说该AC会去请求服务端，并执行相应的逻辑ValidatingAdmissionWebhook，也是一个webhook，只是用于验证 Q: 怎么查看哪些AC是打开了的？A: 文档上写的用：kube-apiserver -h | grep enable-admission-plugins。但是由于本地是minikube，进入虚拟机之后并没有发现kube-apiserver命令。后来发现api-server是以pod的形式运行的：kubectl get pods -n kube-system 于是，使用kubectl exec登入pod，然后调用上述的指令，其结果为：123kube-apiserver -h | grep enable-admission-plugins --admission-control strings Admission is divided into two phases. In the first phase, only mutating admission plugins run. In the second phase, only validating admission plugins run. The names in the below list may represent a validating plugin, a mutating plugin, or both. The order of plugins in which they are passed to this flag does not matter. Comma-delimited list of: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, DefaultStorageClass, DefaultTolerationSeconds, DenyEscalatingExec, DenyExecOnPrivileged, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, Initializers, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodPreset, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, ValidatingAdmissionWebhook. (DEPRECATED: Use --enable-admission-plugins or --disable-admission-plugins instead. Will be removed in a future version.) --enable-admission-plugins strings admission plugins that should be enabled in addition to default enabled ones (NamespaceLifecycle, LimitRanger, ServiceAccount, Priority, DefaultTolerationSeconds, DefaultStorageClass, PersistentVolumeClaimResize, MutatingAdmissionWebhook, ValidatingAdmissionWebhook, ResourceQuota). Comma-delimited list of admission plugins: AlwaysAdmit, AlwaysDeny, AlwaysPullImages, DefaultStorageClass, DefaultTolerationSeconds, DenyEscalatingExec, DenyExecOnPrivileged, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, Initializers, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodPreset, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, ValidatingAdmissionWebhook. The order of plugins in this flag does not matter. Q: Admission webhook是啥？A: 官方定义： Admission webhooks are HTTP callbacks that receive admission requests and do something with them. 简单来说webhook就是一个HTTP回调，接收admission请求，处理并返回。用户可以定义两种webhook: validating admission webhookmutating admission webhook一个用于验证，另一个用于修改。webhook回调，接收API Server发送的admissionReview请求，并返回 admissionResponse。 K: 回调，admissionReview请求，admissionResponse返回。Q: 如何配置和查看WebhookConfiguration?A: 以Validating为例，查看：kubectl get ValidatingWebhookConfiguration ValidatingWebhookConfiguration的资源定义：1234567891011121314151617181920apiVersion: admissionregistration.k8s.io/v1beta1kind: ValidatingWebhookConfigurationmetadata: name: &lt;name of this configuration object&gt;webhooks:- name: &lt;webhook name, e.g., pod-policy.example.io&gt; rules: - apiGroups: - &quot;&quot; apiVersions: - v1 operations: - CREATE resources: - pods clientConfig: service: namespace: &lt;namespace of the front-end service&gt; name: &lt;name of the front-end service&gt; caBundle: &lt;pem encoded ca cert that signs the server cert used by the webhook&gt; 其中rules定义了匹配规则，当发给API Server的请求满足该规则的时候，API Server就会给clientConfig中配置的service发送Admission请求。使用webhook有什么要求？A: 几点： kubernetes版本最低是v1.9api server使能（enable）了MutatingAdmissionWebhook和ValidatingAdmissionWebhookadmissionregistration.k8s.io/v1beta1 API处于enable状态，即使用kubectl api-versions | grep admissionregistration.k8s.io/v1beta1 ###Q: 如何自己写一个webhook? A: 需要完成几个事情：创建TLS Certificate，即证书编写服务端代码，服务端代码需要使用证书根据证书创建k8s sercret创建k8s Deployment和Service创建k8s WebhookConfiguration，其中需要使用之前创建的证书 具体代码和流程参见[3]［4］参考文献：[1] https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/[2] https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks[3] https://banzaicloud.com/blog/k8s-admission-webhooks/[4] https://github.com/morvencao/kube-mutating-webhook-tutorial[5] https://github.com/banzaicloud/admission-webhook-example[6] http://docs.cert-manager.io/en/latest/getting-started/webhook.html 作者：Mr_Hospital链接：https://www.jianshu.com/p/39ae0b6fc907来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[],"tags":[]},{"title":"nats与go-micro  微服务服务之间进行通信","slug":"nats","date":"2019-06-26T03:31:42.000Z","updated":"2019-07-20T03:20:09.872Z","comments":true,"path":"2019/06/26/nats/","link":"","permalink":"https://upengs.github.io/2019/06/26/nats/","excerpt":"","text":"client112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( &quot;awesomeProject/micro_nats_dome/wp/debug&quot; &quot;context&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;time&quot; micro &quot;github.com/micro/go-micro&quot; &quot;github.com/micro/go-plugins/broker/nats&quot; nats2 &quot;github.com/nats-io/go-nats&quot; natsRegistry &quot;github.com/micro/go-plugins/registry/nats&quot; natsTransport &quot;github.com/micro/go-plugins/transport/nats&quot;)var ( addrs = []string&#123;&quot;nats://dev-7:4222&quot;, &quot;nats://dev-8:4222&quot;, &quot;nats://dev-9:4222&quot;&#125; NATS_STREAMING_CLUSTER_ID = &quot;test-cluster&quot; NATS_TOKEN = &quot;NATS12345&quot;)func main() &#123; ctx, cancel := context.WithCancel(context.Background()) defer cancel() natsServers := addrs defaultOptions := nats2.GetDefaultOptions() defaultOptions.ClosedCB = func(conn *nats2.Conn) &#123; fmt.Println(&quot;closed&quot;) &#125; defaultOptions.Servers = natsServers defaultOptions.Token = NATS_TOKEN defaultOptions.ReconnectedCB = func(conn *nats2.Conn) &#123; fmt.Println(&quot;reconnected&quot;) &#125; defaultOptions.DisconnectedCB = func(conn *nats2.Conn) &#123; fmt.Println(&quot;disconnected&quot;) &#125; defaultOptions.DiscoveredServersCB = func(conn *nats2.Conn) &#123; fmt.Println(&quot;disccoveredservice&quot;) &#125; // var err error registry := natsRegistry.NewRegistry(natsRegistry.Options(defaultOptions)) transport := natsTransport.NewTransport(natsTransport.Options(defaultOptions)) broker := nats.NewBroker(nats.Options(defaultOptions)) service := micro.NewService( micro.Name(&quot;greeter&quot;), micro.Registry(registry), micro.Broker(broker), micro.Transport(transport), micro.Context(ctx), ) c := service.Client() time.Sleep(1 * time.Second) response, err := debug.NewGreeterService(&quot;greeter&quot;, c).Hello(context.TODO(), &amp;debug.Request&#123;Name: &quot;xxxxxx&quot;&#125;) if err != nil &#123; return &#125; b, _ := json.Marshal(response) fmt.Println(string(b))&#125; client2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport ( &quot;awesomeProject/micro_nats_dome/wp/debug&quot; &quot;context&quot; &quot;fmt&quot; &quot;time&quot; micro &quot;github.com/micro/go-micro&quot; &quot;github.com/micro/go-plugins/broker/nats&quot; gonats &quot;github.com/nats-io/go-nats&quot; // nats &quot;github.com/nats-io/nats.go&quot; natsRegistry &quot;github.com/micro/go-plugins/registry/nats&quot; natsTransport &quot;github.com/micro/go-plugins/transport/nats&quot;)var ( addrs1 = []string&#123;&quot;nats://dev-7:4222&quot;, &quot;nats://dev-8:4222&quot;, &quot;nats://dev-9:4222&quot;&#125; NATS_STREAMING_CLUSTER_ID1 = &quot;test-cluster&quot; NATS_TOKEN1 = &quot;NATS12345&quot;)type Greeter struct&#123;&#125;func (g *Greeter) Hello(ctx context.Context, req *debug.Request, rsp *debug.Response) error &#123; rsp.Msg = &quot;Hello 3&quot; + req.Name fmt.Println(rsp.Msg) return nil&#125;func main() &#123; ctx, cancel := context.WithCancel(context.Background()) defer cancel() natsServers := addrs1 defaultOptions := gonats.GetDefaultOptions() defaultOptions.ClosedCB = func(conn *gonats.Conn) &#123; fmt.Println(&quot;closed&quot;) &#125; defaultOptions.Servers = natsServers defaultOptions.Token = NATS_TOKEN1 defaultOptions.ReconnectedCB = func(conn *gonats.Conn) &#123; fmt.Println(&quot;reconnected&quot;) &#125; defaultOptions.DisconnectedCB = func(conn *gonats.Conn) &#123; fmt.Println(&quot;disconnected&quot;) &#125; defaultOptions.DiscoveredServersCB = func(conn *gonats.Conn) &#123; fmt.Println(&quot;disccoveredservice&quot;) &#125; registry := natsRegistry.NewRegistry(natsRegistry.Options(defaultOptions)) transport := natsTransport.NewTransport(natsTransport.Options(defaultOptions)) broker := nats.NewBroker( nats.Options(defaultOptions), ) var err error service := micro.NewService( micro.Name(&quot;greeter&quot;), micro.Registry(registry), micro.Broker(broker), micro.Transport(transport), micro.Context(ctx), ) time.Sleep(2 * time.Second) debug.RegisterGreeterHandler(service.Server(), &amp;Greeter&#123;&#125;) err = service.Run() if err != nil &#123; fmt.Println(err) &#125;&#125; hello.proto12345678910111213syntax = &quot;proto3&quot;;service Greeter &#123; rpc Hello(Request) returns (Response) &#123;&#125;&#125;message Request &#123; string name = 1;&#125;message Response &#123; string msg = 1;&#125;","categories":[],"tags":[]},{"title":"使用kubeam install kubernets v1.15.0 实现master高可用","slug":"kubeadm","date":"2019-06-25T10:27:03.000Z","updated":"2019-06-28T08:52:09.831Z","comments":true,"path":"2019/06/25/kubeadm/","link":"","permalink":"https://upengs.github.io/2019/06/25/kubeadm/","excerpt":"","text":"确保每台node都安装了 docker参考：https://docs.docker.com/install/linux/docker-ce/centos/ kubeadm-config.yaml12345678apiVersion: kubeadm.k8s.io/v1beta2kind: ClusterConfigurationkubernetesVersion: 1.15.0controlPlaneEndpoint: &quot;10.0.0.101:8443&quot; # haproxy hostimageRepository: registry.aliyuncs.com/google_containersnetworking: podSubnet: 10.148.0.0/16 serviceSubnet: 10.196.0.0/12 haproxy.cfg1docker run -d --net host --name haproxy -v $(pwd)/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg haproxy:2.0 123456789101112131415161718192021222324252627282930313233343536373839404142global maxconn 10000 #默认最大连接数 log 127.0.0.1 local0 #[err warning info debug] chroot /usr/local/sbin #chroot运行的路径 daemon #以后台形式运行haproxy pidfile /var/run/haproxy.piddefaults log 127.0.0.1 local3 mode http #所处理的类别 (#7层 http;4层tcp ) maxconn 10000 #最大连接数 option dontlognull #不记录健康检查的日志信息 option redispatch #serverId对应的服务器挂掉后,强制定向到其他健康的服务器 #stats refresh 30 #统计页面刷新间隔 retries 3 #3次连接失败就认为服务不可用，也可以通过后面设置 balance roundrobin #默认的负载均衡的方式,轮询方式 #balance source #默认的负载均衡的方式,类似nginx的ip_hash #balance leastconn #默认的负载均衡的方式,最小连接 timeout connect 5000 #连接超时 timeout client 50000 #客户端超时 timeout server 50000 #服务器超时 timeout check 2000 #心跳检测超时listen admin_stats bind 0.0.0.0:10080 mode http log 127.0.0.1 local0 err stats refresh 30s stats uri /status stats realm welcome login\\ Haproxy stats auth admin:123456 stats hide-version stats admin if TRUElisten kube-master bind 0.0.0.0:8443 mode tcp option tcplog balance source server 10.0.0.106 10.0.0.106:6443 check inter 2000 fall 2 rise 2 weight 1 server 10.0.0.102 10.0.0.102:6443 check inter 2000 fall 2 rise 2 weight 1 server 10.0.0.101 10.0.0.101:6443 check inter 2000 fall 2 rise 2 weight 1 在每台node上执行，kubectl 建议只在在master 安装123456789101112131415161718192021222324cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --systemsetenforce 0swapoff -ased -i &apos;s/^SELINUX=enforcing$/SELINUX=permissive/&apos; /etc/selinux/configcat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF# 安装yum install -y kubectl kubelet kubeadm# 开机启动systemctl enable kubelet# 启动systemctl start kubelet 初始化第一套集群,完成之后按照提示 cp /etc/kubernetes/admin.conf ~/.kube/config1kubeadm init --config=kubeadm-config.yaml --upload-certs -v=10 安装flannel网络1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml 添加master 节点12如果忘了--certificate-key 值就用这个命令去master 生成一个kubeadm init phase upload-certs --experimental-upload-certs 123kubeadm join 10.0.0.101:8443 --token u20jmk.7cnbp7soe1e7vr4l \\ --discovery-token-ca-cert-hash sha256:3a5206c743a9369c2386db8bf181b78765862c4eb9caf12e332b6868db20633a \\ --experimental-control-plane --certificate-key 4af91f16c3997bc59a56cfc0e3061f6086c62012f4e7e4ed9da84b4622fc9d89 添加worker 节点12345kubeadm join 10.0.0.101:8443 --token u20jmk.7cnbp7soe1e7vr4l \\ --discovery-token-ca-cert-hash sha256:3a5206c743a9369c2386db8bf181b78765862c4eb9caf12e332b6868db20633a 可以print一个 join cluster commandkubeadm token create --print-join-command 其他命令1kubeadm reset //重置node 参考：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/","categories":[],"tags":[]},{"title":"https_harbor 搭建","slug":"https-harbor","date":"2019-06-25T10:19:53.000Z","updated":"2019-07-02T12:50:36.792Z","comments":true,"path":"2019/06/25/https-harbor/","link":"","permalink":"https://upengs.github.io/2019/06/25/https-harbor/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940openssl genrsa -out ca.key 4096openssl req -x509 -new -nodes -sha512 -days 3650 \\ -subj &quot;/C=TW/ST=Taipei/L=Taipei/O=example/OU=Personal/CN=yourdomain.com&quot; \\ -key ca.key \\ -out ca.crtopenssl genrsa -out yourdomain.com.key 4096openssl req -sha512 -new \\ -subj &quot;/C=TW/ST=Taipei/L=Taipei/O=example/OU=Personal/CN=yourdomain.com&quot; \\ -key yourdomain.com.key \\ -out yourdomain.com.csrcat &gt; v3.ext &lt;&lt;-EOFauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1=yourdomain.comDNS.2=yourdomainDNS.3=https-harborDNS.4=10.0.0.88EOFopenssl x509 -req -sha512 -days 3650 \\ -extfile v3.ext \\ -CA ca.crt -CAkey ca.key -CAcreateserial \\ -in yourdomain.com.csr \\ -out yourdomain.com.crtmkdir -p /data/cert/cp yourdomain.com.crt /data/cert/cp yourdomain.com.key /data/cert/openssl x509 -inform PEM -in yourdomain.com.crt -out yourdomain.com.certmkdir -p /etc/docker/certs.d/yourdomain.com/cp yourdomain.com.cert /etc/docker/certs.d/yourdomain.com/cp yourdomain.com.key /etc/docker/certs.d/yourdomain.com/cp ca.crt /etc/docker/certs.d/yourdomain.com/ 参考：https://github.com/goharbor/harbor/blob/master/docs/configure_https.md","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://upengs.github.io/tags/docker/"},{"name":"harbor","slug":"harbor","permalink":"https://upengs.github.io/tags/harbor/"}]},{"title":" https证书制作","slug":"ca","date":"2019-06-23T14:53:42.000Z","updated":"2019-07-02T12:48:31.117Z","comments":true,"path":"2019/06/23/ca/","link":"","permalink":"https://upengs.github.io/2019/06/23/ca/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bash# step 1 为服务器端和客户端准备公钥、私钥# 生成服务器端私钥openssl genrsa -out server.key 1024# 生成服务器端公钥openssl rsa -in server.key -pubout -out server.pem# step 2 生成 CA 证书# 生成客户端私钥openssl genrsa -out client.key 1024# 生成客户端公钥openssl rsa -in client.key -pubout -out client.pem# 生成 CA 私钥openssl genrsa -out ca.key 1024# X.509 Certificate Signing Request (CSR) Management.openssl req -new -key ca.key -out ca.csr# X.509 Certificate Data Management.openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt# ➜ keys openssl req -new -key ca.key -out ca.csr# You are about to be asked to enter information that will be incorporated# into your certificate request.# What you are about to enter is what is called a Distinguished Name or a DN.# There are quite a few fields but you can leave some blank# For some fields there will be a default value,# If you enter &apos;.&apos;, the field will be left blank.# -----# Country Name (2 letter code) [AU]:CN# State or Province Name (full name) [Some-State]:Zhejiang# Locality Name (eg, city) []:Hangzhou# Organization Name (eg, company) [Internet Widgits Pty Ltd]:My CA# Organizational Unit Name (eg, section) []:# Common Name (e.g. server FQDN or YOUR name) []:localhost# Email Address []:# step 3 生成服务器端证书和客户端证书# 服务器端需要向 CA 机构申请签名证书，在申请签名证书之前依然是创建自己的 CSR 文件openssl req -new -key server.key -out server.csr# 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt# client 端openssl req -new -key client.key -out client.csr# client 端到 CA 签名openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt获取服务端签名, 即server.crt的内容:openssl x509 -in &lt;(openssl s_client -showcerts -servername dfdaemon.com -connect dfdaemon.com:65001 -prexit 2&gt;/dev/null) 1234567891011121314151617181920212223openssl x509部分命令打印出证书的内容：openssl x509 -in cert.pem -noout -text打印出证书的系列号openssl x509 -in cert.pem -noout -serial打印出证书的拥有者名字openssl x509 -in cert.pem -noout -subject以RFC2253规定的格式打印出证书的拥有者名字openssl x509 -in cert.pem -noout -subject -nameopt RFC2253在支持UTF8的终端一行过打印出证书的拥有者名字openssl x509 -in cert.pem -noout -subject -nameopt oneline -nameopt -escmsb打印出证书的MD5特征参数openssl x509 -in cert.pem -noout -fingerprint打印出证书的SHA特征参数openssl x509 -sha1 -in cert.pem -noout -fingerprint把PEM格式的证书转化成DER格式openssl x509 -in cert.pem -inform PEM -out cert.der -outform DER把一个证书转化成CSRopenssl x509 -x509toreq -in cert.pem -out req.pem -signkey key.pem给一个CSR进行处理，颁发字签名证书，增加CA扩展项openssl x509 -req -in careq.pem -extfile openssl.cnf -extensions v3_ca -signkey key.pem -out cacert.pem给一个CSR签名，增加用户证书扩展项openssl x509 -req -in req.pem -extfile openssl.cnf -extensions v3_usr -CA cacert.pem -CAkey key.pem -CAcreateserial","categories":[],"tags":[]},{"title":"Mac 键盘快捷键","slug":"mac-key","date":"2019-04-21T01:58:27.000Z","updated":"2019-04-21T02:13:29.716Z","comments":true,"path":"2019/04/21/mac-key/","link":"","permalink":"https://upengs.github.io/2019/04/21/mac-key/","excerpt":"","text":"##Mac 键盘快捷键您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常对某些按键使用符号，其中包括以下修饰键： Command（或 Cmd）⌘Shift ⇧Option（或 Alt）⌥Control（或 Ctrl）⌃Caps Lock ⇪Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。 Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–Power 电源按钮：*强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (:)：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 参考：https://support.apple.com/zh-cn/HT201236","categories":[],"tags":[]},{"title":"iterm2 快捷键","slug":"iterm2","date":"2019-04-21T01:50:59.000Z","updated":"2019-04-21T02:13:29.713Z","comments":true,"path":"2019/04/21/iterm2/","link":"","permalink":"https://upengs.github.io/2019/04/21/iterm2/","excerpt":"","text":"command + t 新建标签 command + w 关闭标签 command + 数字 command + 左右方向键 切换标签 command + enter 切换全屏 command + f 查找 command + d 垂直分屏 command + shift + d 水平分屏 command + option + 方向键 command + [ 或 command + ] 切换屏幕 command + ; 查看历史命令 command + shift + h 查看剪贴板历史 ctrl + u 清除当前行 ctrl + l 清屏 ctrl + a 到行首 ctrl + e 到行尾 ctrl + f/b 前进后退 ctrl + p 上一条命令 ctrl + r 搜索命令历史","categories":[],"tags":[]},{"title":"shell基本命令","slug":"shell-1","date":"2019-04-21T01:36:41.000Z","updated":"2019-04-21T11:05:58.320Z","comments":true,"path":"2019/04/21/shell-1/","link":"","permalink":"https://upengs.github.io/2019/04/21/shell-1/","excerpt":"","text":"shell基本命令把多个文件夹中的内容复制到同一个文件下1cp -r ./file1 ./file2 /root uname -r 获取系统版本12sh-4.2# uname -r3.10.0-957.10.1.el7.x86_64 unset重新设置变量内容1unset name date 格式化12345sh-4.2# date +%Y/%m/%d2019/04/21sh-4.2# date +%H:%m08:04 cal 查看日历 bc 计算器 搜索：12/string 向上搜索N?string 向下搜索n 正确的关机方法123shutdownpoweroffhalt 重启方法1reboot 添加用户和密码12useradd wppasswd wp","categories":[],"tags":[]},{"title":"yum  源加速设置","slug":"yum","date":"2019-04-13T02:29:37.000Z","updated":"2019-07-02T13:19:11.244Z","comments":true,"path":"2019/04/13/yum/","link":"","permalink":"https://upengs.github.io/2019/04/13/yum/","excerpt":"","text":"yum 安装完成后生成的配置文件及目录： 主配置文件：/etc/yum.conf资源库配置目录：/etc/yum.repos.d重要文件： /etc/yum.repos.d/CentOS-Base.repoyum 加速插件：实现的功能：可以自动选择速度最快的镜像 安装yum 加速插件：yum install yum-plugin-fastestmirror加速插件的配置文件：/etc/yum/pluginconf.d/fastestmirror.confyum镜像的速度测试记录文件：/var/cache/yum/timedhosts.txt更换系统默认yum 源举例：以更换yum源为阿里云yum源 备份系统默认的yum源mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载阿里云yum源 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 添加 epel 源 yum -y install epel-release.noarch常用的yum源epel源：https://fedoraproject.org/wiki/EPELrepoforge源：http://repoforge.org/use/php和mysql源：https://webtatic.com 清理缓存yum clean all 生成新的缓存yum makecache","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://upengs.github.io/tags/linux/"}]},{"title":"ansible","slug":"ansible","date":"2019-04-12T15:44:42.000Z","updated":"2019-07-02T12:48:19.962Z","comments":true,"path":"2019/04/12/ansible/","link":"","permalink":"https://upengs.github.io/2019/04/12/ansible/","excerpt":"","text":"#install ansible1234python --versionPython 2.7.10sudo easy_install pipsudo pip install ansible dome :https://blog.csdn.net/pushiqiang/article/details/78126063 1ansible -i ./hosts local --connection=local -b --become-user=root -m shell -a &quot;ls&quot; 123-b - “成为”，在运行命令时告诉可以成为另一个用户。--become-user=root - 以用户“root”运行以下命令（例如，使用命令使用“sudo”）。我们可以在此定义任何现有的用户。-a 用于将任何参数传递给定义的模块 -m 进行免密登陆12ssh-agentssh-copy-id root@127.0.0.1","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://upengs.github.io/tags/python/"}]},{"title":"如何在 Linux 中不使用 CD 命令进入目录/文件夹","slug":"如何在-Linux-中不使用-CD-命令进入目录-文件夹","date":"2019-04-12T02:00:06.000Z","updated":"2019-07-02T13:19:11.224Z","comments":true,"path":"2019/04/12/如何在-Linux-中不使用-CD-命令进入目录-文件夹/","link":"","permalink":"https://upengs.github.io/2019/04/12/如何在-Linux-中不使用-CD-命令进入目录-文件夹/","excerpt":"","text":"众所周知，如果没有 cd 命令，我们无法 Linux 中切换目录。这个没错，但我们有一个名为 shopt的 Linux 内置命令能帮助我们解决这个问题。 shopt[1] 是一个 shell 内置命令，用于设置和取消设置各种 bash shell 选项，由于它已安装，因此我们不需要再次安装它。 是的，我们可以在启用此选项后，可以不使用 cd 命令切换目录。 我们将在本文中向你展示如何操作。这是一个小的调整，但对于那些从 Windows 迁移到 Linux 的新手来说非常有用。 这对 Linux 管理员没用，因为我们不会在没有 cd 命令的情况下切换到该目录，因为我们对此有经验。 如果你尝试在没有 cd 命令的情况下切换 Linux 的目录/文件夹，你将看到以下错误消息。这在 Linux 中很常见。 $ Documents/bash: Documents/: Is a directory为此，我们需要在用户 .bashrc 中追加以下值。 什么是 .bashrc ？ .bashrc 是一个 shell 脚本，每次用户以交互模式打开新 shell 时都会运行该脚本。 你可以在该文件中添加要在命令提示符下输入的任何命令。 .bashrc 文件本身包含终端会话的一系列配置。包括设置和启用：着色、补全，shell 历史，命令别名等。 $ vi ~/.bashrc加入这一行： shopt -s autocd运行以下命令使更改生效。 $ source ~/.bashrc我们已完成所有配置。简单地对此进行测试以确认这是否有效。 $ Documents/cd – Documents/$ daygeek/cd – daygeek/$ /home/daygeek/Documents/daygeekcd – /home/daygeek/Documents/daygeek$ pwd/home/daygeek/Documents/daygeek 是的，它正如预期的那样正常工作。 而且，它在 fish shell 中工作正常，而无需对 .bashrc 进行任何更改。 如果要暂时执行此操作，请使用以下命令（设置或取消设置）。重启系统时，它将消失。 shopt -s autocdshopt | grep autocdautocd on shopt -u autocdshopt | grep autocdautocd offshopt 命令提供了许多其他选项，如果要验证这些选项，请运行以下命令。 $ shoptautocd onassoc_expand_once offcdable_vars offcdspell oncheckhash offcheckjobs offcheckwinsize oncmdhist oncompat31 offcompat32 offcompat40 offcompat41 offcompat42 offcompat43 offcompat44 offcomplete_fullquote ondirexpand offdirspell offdotglob offexecfail offexpand_aliases onextdebug offextglob offextquote onfailglob offforce_fignore onglobasciiranges onglobstar offgnu_errfmt offhistappend onhistreedit offhistverify offhostcomplete onhuponexit offinherit_errexit offinteractive_comments onlastpipe offlithist offlocalvar_inherit offlocalvar_unset offlogin_shell offmailwarn offno_empty_cmd_completion offnocaseglob offnocasematch offnullglob offprogcomp onprogcomp_alias offpromptvars onrestricted_shell offshift_verbose offsourcepath onxpg_echo off此外，我找到了一些其他程序，它们可以帮助我们在 Linux 中比 cd 命令更快地切换目录。 它们是 pushd、popd、up shell 脚本和 bd 工具。我们将在接下来的文章中介绍这些主题。 via: https://www.2daygeek.com/navigate-switch-directory-without-using-cd-command-in-linux/","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://upengs.github.io/tags/linux/"}]},{"title":"vim基本操作","slug":"vim","date":"2019-04-08T13:49:32.000Z","updated":"2019-07-02T13:19:11.205Z","comments":true,"path":"2019/04/08/vim/","link":"","permalink":"https://upengs.github.io/2019/04/08/vim/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556w 或 W 光标移动至下一个单词的单词首b 或 B 光标移动至上一个单词的单词首e 或 E 光标移动至下一个单词的单词尾nw 或 nW n 为数字，表示光标向右移动 n 个单词nb 或 nB n 为数字，表示光标向左移动 n 个单词0 或 ^ 光标移动至当前行的行首$ 光标移动至当前行的行尾n$ 光标移动至当前行只有 n 行的行尾，n为数字例如，在査看 /etc/passwd 时需要参考 /etc/shadow，有两种办法可以实现：先使用 Vim 打开第一个文件，接着输入命 令 &quot;:sp/etc/shadow&quot; 水平切分窗口，然后按回车键；如果想垂直切分窗口则可以输入 &quot;:vs/etc/shadow&quot;;可以直接执行命令&quot;vim -o 第一个文件名 第二个文件名&quot;，也就是 &quot;vim-o /etc/passwd /etc/shadow&quot;。如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令 &quot;:r 被复制的文件名&quot;，即可将导入文件的全部内容复制到当前光标所在行下面。设置参数 含 义:set nu:set nonu 设置与取消行号。:syn on:syn off 是否依据语法显示相关的颜色帮助。在Vim中修改相关的配置文件或Shell脚本文件 时（如前面示例的脚本/etc/init.d/sshd)，默认会显示相应的颜色，用来帮助排错。如果觉得颜色产生了干扰，则可以取消此设置set hlsearchset nohlsearch 设置是否将査找的字符串高亮显示。默认是hlsearch高亮显示set nobackupset backup 是否保存自动备份文件。默认是nobackup不自动备份。如果设定了:set backup，则会产生“文件名〜”作为备份文件set rulerset noruler 设置是否显示右下角的状态栏。默认是ruler显示set showmodeset noshowmode 设置是否在左下角显示如“一INSERT--”之类的状态栏。默认是showmode显示 x 删除当前光标下的字符(&quot;dl&quot;的快捷命令) X 删除当前光标之前的字符(&quot;dh&quot;的快捷命令) D 删除自当前光标至行尾的内容(&quot;d$&quot;的快捷命令) dw 删除自当前光标至下一个word的开头 db 删除自当前光标至前一个word的开始 diw 删除当前光标所在的word(不包括空白字符) daw 删除当前光标所在的word(包括空白字符) dG 删除当前行至文件尾的内容 dgg 删除当前行至文件头的内容 如果你用&quot;c&quot;命令代替&quot;d&quot;这些命令就都变成更改命令。使用&quot;y&quot;就是yank命令，如此类推。 在文本中查找下一个word 把光标定位于这个word上然后按下&quot;*&quot;键。Vim将会取当前光标所在的word并将它作用目标字符串进行搜索。&quot;#&quot;命令是&quot;*&quot;的反向版。还可以在这两个命令前加一个命令计数:&quot;3*&quot;查找当前光标下的word的第三次出现。# 大小写转换guu : 行小写gUU : 行大写g~~ : 行翻转","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://upengs.github.io/tags/linux/"}]},{"title":"kubernetes","slug":"kubernetes","date":"2019-03-27T14:12:04.000Z","updated":"2019-06-25T02:27:04.554Z","comments":true,"path":"2019/03/27/kubernetes/","link":"","permalink":"https://upengs.github.io/2019/03/27/kubernetes/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --systemsetenforce 0swapoff -ased -i &apos;s/^SELINUX=enforcing$/SELINUX=permissive/&apos; /etc/selinux/configcat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF# 安装yum install -y kubectl kubelet kubeadm# 开机启动systemctl enable kubelet# 启动systemctl start kubeletkubeadm init --kubernetes-version=1.15.0 --apiserver-advertise-address=10.0.0.101 --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16 -v=10https://www.jianshu.com/p/b58c85436f0akubeadm init --kubernetes-version=1.15.0 --apiserver-advertise-address=10.0.0.106 --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16 -v=10install cnikubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml 123pod 优先级调度参考：https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/ PriorityClass crdhttps://sq.163yun.com/blog/article/174980128954048512 123456789101112Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动。可以通过kubelet的启动参数--fail-swap-on=false更改这个限制。全局关闭：关闭系统的Swap方法如下:swapoff -a 修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 &gt; swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：vm.swappiness=0 执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。 etcdctl –endpoints=https://[127.0.0.1]:2379 –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt –key=/etc/kubernetes/pki/etcd/healthcheck-client.key get foo export HOST0=10.0.0.106export HOST1=10.0.0.101export HOST2=10.0.0.108 mkdir -p /tmp/${HOST0}/ /tmp/${HOST1}/ /tmp/${HOST2}/ ETCDHOSTS=(${HOST0} ${HOST1} ${HOST2})NAMES=(“infra0” “infra1” “infra2”) for i in “${!ETCDHOSTS[@]}”; doHOST=${ETCDHOSTS[$i]}NAME=${NAMES[$i]}cat &lt;&lt; EOF &gt; /tmp/${HOST}/kubeadmcfg.yamlapiVersion: “kubeadm.k8s.io/v1beta2”kind: ClusterConfigurationetcd: local: serverCertSANs: - &quot;${HOST}&quot; peerCertSANs: - &quot;${HOST}&quot; extraArgs: initial-cluster: ${NAMES[0]}=https://${ETCDHOSTS[0]}:2380,${NAMES[1]}=https://${ETCDHOSTS[1]}:2380,${NAMES[2]}=https://${ETCDHOSTS[2]}:2380 initial-cluster-state: new name: ${NAME} listen-peer-urls: https://${HOST}:2380 listen-client-urls: https://${HOST}:2379 advertise-client-urls: https://${HOST}:2379 initial-advertise-peer-urls: https://${HOST}:2380 EOFdone","categories":[],"tags":[]},{"title":"go-mod","slug":"go-mod","date":"2019-03-12T01:29:24.000Z","updated":"2019-07-17T08:44:59.845Z","comments":true,"path":"2019/03/12/go-mod/","link":"","permalink":"https://upengs.github.io/2019/03/12/go-mod/","excerpt":"","text":"https://ieevee.com/tech/2019/02/19/go-mod-proxy.html https://medium.com/@diogok/on-golang-static-binaries-cross-compiling-and-plugins-1aed33499671 123456789export GOPROXY=https://mirrors.aliyun.com/goproxy/GO111MODULE=on go mod initGOPROXY=https://gocenter.io GO111MODULE=on go mod vendorhttps://goproxy.io在当前项目下，手动运行go mod tidy这条命令会自动更新依赖关系，并且将包下载放入cache。在GOPATH/pkg/mod/下。GOPROXY=https://gocenter.io GO111MODULE=on go mod tidy docker run -d -p 14000:14000 -p 15002:15002 -p 15001:15001 -p 15003:15003 -p 15004:15004 -p 15000:15000 -v /Users/wupeng/go/src/github.com/uber/kraken/examples/devcluster/config/origin/development.yaml:/etc/kraken/config/origin/development.yaml -v /Users/wupeng/go/src/github.com/uber/kraken/examples/devcluster/config/tracker/development.yaml:/etc/kraken/config/tracker/development.yaml -v /Users/wupeng/go/src/github.com/uber/kraken/examples/devcluster/config/build-index/development.yaml:/etc/kraken/config/build-index/development.yaml -v /Users/wupeng/go/src/github.com/uber/kraken/examples/devcluster/config/proxy/development.yaml:/etc/kraken/config/proxy/development.yaml -v /Users/wupeng/go/src/github.com/uber/kraken/examples/devcluster/herd_param.sh:/etc/kraken/herd_param.sh -v /Users/wupeng/go/src/github.com/uber/kraken/examples/devcluster/herd_start_processes.sh:/etc/kraken/herd_start_processes.sh –name kraken-herd kraken-herd:v0.1.0-25-ga61fa4f ./herd_start_processes.sh","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://upengs.github.io/tags/golang/"}]},{"title":"protobuf的安装","slug":"protobuf","date":"2019-03-07T01:58:58.000Z","updated":"2019-07-20T03:19:14.188Z","comments":true,"path":"2019/03/07/protobuf/","link":"","permalink":"https://upengs.github.io/2019/03/07/protobuf/","excerpt":"","text":"mac protoc-3.7.0-osx-x86_64.zip https://github.com/protocolbuffers/protobuf/releases/tag/v3.7.0 https://github.com/golang/protobufhttps://github.com/micro/protoc-gen-micro","categories":[],"tags":[]},{"title":"pprof","slug":"pprof","date":"2019-03-06T15:18:18.000Z","updated":"2019-04-20T03:39:51.802Z","comments":true,"path":"2019/03/06/pprof/","link":"","permalink":"https://upengs.github.io/2019/03/06/pprof/","excerpt":"","text":"CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况 cpu（CPU Profiling）: $HOST/debug/pprof/profile，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件block（Block Profiling）：$HOST/debug/pprof/block，查看导致阻塞同步的堆栈跟踪goroutine：$HOST/debug/pprof/goroutine，查看当前所有运行的 goroutines 堆栈跟踪heap（Memory Profiling）: $HOST/debug/pprof/heap，查看活动对象的内存分配情况mutex（Mutex Profiling）：$HOST/debug/pprof/mutex，查看导致互斥锁的竞争持有者的堆栈跟踪threadcreate：$HOST/debug/pprof/threadcreate，查看创建新OS线程的堆栈跟踪 https://www.jianshu.com/p/4e4ff6be6af9 https://www.cnblogs.com/li-peng/p/9391543.html go tool pprof httpdemo http://192.168.3.34:9909/debug/pprof/profile top list handleData mac环境下graphviz安装及使用 https://blog.csdn.net/mouday/article/details/80902025","categories":[],"tags":[]},{"title":"kubernetes排除应用程序故障","slug":"排除应用程序故障","date":"2019-02-27T13:23:00.000Z","updated":"2019-07-02T13:19:11.197Z","comments":true,"path":"2019/02/27/排除应用程序故障/","link":"","permalink":"https://upengs.github.io/2019/02/27/排除应用程序故障/","excerpt":"","text":"访问上一个容器崩溃的日志 1kubernetes logs --previous pod_name container_name 修改image1kubectl set image deployments/deploy_name container_name=image kcc delete po -n default $(kcc get po -n defalut |grep nginx |awk ‘{print $1}’) –force –grace-period=0 docker rm -f $(docker ps -aq –filter exited=1) 可以直接进入容器终端kubectl run curl –image=radial/busyboxplus:curl -i –tty -n wp kubectl exec podname -c containername – printenv","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://upengs.github.io/tags/kubernetes/"}]},{"title":"redis","slug":"redis","date":"2019-02-27T03:49:23.000Z","updated":"2019-07-02T13:19:11.230Z","comments":true,"path":"2019/02/27/redis/","link":"","permalink":"https://upengs.github.io/2019/02/27/redis/","excerpt":"","text":"github.com/garyburd/redigo/redis遇到的坑：并发Connections支持Receive方法的一个并发调用者和Send和Flush方法的一个并发调用者。不支持其他并发，包括对Do和Close方法的并发调用。要完全并发访问Redis，请使用线程安全池从goroutine中获取，使用和释放连接。从池返回的连接具有上一段中描述的并发限制。 清空redis 数据1flushall","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://upengs.github.io/tags/redis/"}]},{"title":"版本管理工具 git相关命令","slug":"git","date":"2019-02-26T14:02:36.000Z","updated":"2019-07-30T09:10:25.168Z","comments":true,"path":"2019/02/26/git/","link":"","permalink":"https://upengs.github.io/2019/02/26/git/","excerpt":"","text":"Git 新建分支：v1.1.1 1git branch v1.1.1 或 1git branch -b v1.1.1 //新建分支并切换到新建分支home@DESKTOP-S967PDA MINGW64 /f/gitPractise/gitDemo (v1.1.2) 1$ git checkout -b v1.1.5 v1.1.2 切换分支： 1git checkout v1.1.1 //把分支push 到remote 1git push orign v1.1.1 //修改branch 的名字 1git branch -m v1.1.1 v1.1.2 //删除branch 1git push origin --delete v1.1.1 添加文件到git将当前目录下所有变化的文件，放入暂存区 12git add .git add ./ //参数表示只添加暂存区已有的文件（包括删除操作），但不添加新增的文件。 1git add -u //查看本地branch 分支 123git branch git branch -v //查看本地和远程的分支 1git branch -a //查看 远程remote 分支 1git branch -r //比较文件差异 1git diff //删除分支(前提条件是该分支没有被合并) 1git branch -d v1.1.1 //强制删除一个分支，不管该分支有没有被合并 git branch -D v1.1.1 //查看merge的情况git branch –merged 将工作区制定的文件还原到上次commit的状态git checkout xxx.txt //切换到某个tag git checkout tags/1.1.4或git checkout 1.1.4 //命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。 1git cherry-pick xxxxx //根据一个树对象，生成新的commit对象。 git commit-tree 16e19f -m “First commit” 查看工作区与暂存区的差异 1$ git diff 查看某个文件的工作区与暂存区的差异 1$ git diff file.txt 查看暂存区与当前 commit 的差异 1$ git diff --cached 12 查看两个commit的差异 1$ git diff &lt;commitBefore&gt; &lt;commitAfter 查看暂存区与仓库区的差异 1$ git diff --cached 查看工作区与上一次commit之间的差异即如果执行 git commit -a，将提交的文件 1$ git diff HEAD 查看工作区与某个 commit 的差异 1$ git diff &lt;commit&gt; 显示两次提交之间的差异 1$ git diff [first-branch]...[second-branch] 查看工作区与当前分支上一次提交的差异，但是局限于test文件 1$ git diff HEAD -- ./test 查看当前分支上一次提交与上上一次提交之间的差异 1$ git diff HEAD -- ./test 生成patch 1$ git format-patch master --stdout &gt; mypatch.patch 12 查看topic分支与master分支最新提交之间的差异 1$ git diff topic master 与上一条命令相同 1$ git diff topic..master 查看自从topic分支建立以后，master分支发生的变化 1$ git diff topic...master 12 命令将当前目录转为git仓库。 1git init 命令按照提交时间从最晚到最早的顺序，列出所有 commit。 1git log git remote为远程仓库添加别名。 1it remote add john git@github.com:johnsomeone/someproject.git 显示所有的远程主机 1git remote -v 列出某个主机的详细信息 1git remote show name git revertgit revert命令用于撤销commit。 1git revert &lt;commitID&gt; git rmgit rm命令用于删除文件。 解除追踪某个文件，即该文件已被git add添加，然后抵消这个操作。 12345678910111213141516$ git rm --cached &lt;fileName&gt;git showgit show命令用于查看commit的内容# 输出某次提交的元数据和内容变化$ git show [commit]$ git show 12a86bc38 # By revision$ git show v1.0.1 # By tag$ git show feature132 # By branch name$ git show 12a86bc38^ # Parent of a commit$ git show 12a86bc38~2 # Grandparent of a commit$ git show feature132@&#123;yesterday&#125; # Time relative$ git show feature132@&#123;2.hours.ago&#125; # Time relative git merge master1234567891011121314151617181920212223home@DESKTOP-S967PDA MINGW64 /f/gitPractise/gitDemo (v1.1.5)$ git merge masterAlready up-to-date.home@DESKTOP-S967PDA MINGW64 /f/gitPractise/gitDemo (v1.1.5)$ git checkout v1.1.5Already on &apos;v1.1.5&apos;home@DESKTOP-S967PDA MINGW64 /f/gitPractise/gitDemo (v1.1.5)$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;origin/master&apos;.home@DESKTOP-S967PDA MINGW64 /f/gitPractise/gitDemo (master)$ git merge v1.1.5Updating 891e496..f6a3810Fast-forward dome.txt | 1 + 1 file changed, 1 insertion(+)home@DESKTOP-S967PDA MINGW64 /f/gitPractise/gitDemo (master)$ cat dome.txtgjkdsjsdjfjjgjksjdjfkdsjfsjffjkdsjfsjkfjksjfjsdjjsf 查看提交日志 12git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL 回退版本 1git reset --hard 1094adb7b9b3807259d8cb349e7df1d4d6477073 查看远程分支加上-a参数可以查看远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）：$ git branch -a master remote tungway v1.52 zrongremotes/origin/masterremotes/origin/tungwayremotes/origin/v1.52remotes/origin/zrong删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支： 1$ git push origin –delete 删除tag这么用： 1git push origin –delete tag 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支： 1git push origin :这是删除tag的方法，推送一个空tag到远程tag： $ git remote show origin remote originFetch URL: git@github.com:xxx/xxx.gitPush URL: git@github.com:xxx/xxx.gitHEAD branch: masterRemote branches: master tracked refs/remotes/origin/b1 stale (use ‘git remote prune’ to remove)Local branch configured for ‘git pull’: master merges with remote masterLocal ref configured for ‘git push’: master pushes to master (up to date)这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。 更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支： 1git fetch -p重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 例如下面的例子中，我需要把 devel 分支重命名为 develop 分支： $ git branch -av devel 752bb84 Merge pull request #158 from Gwill/develmaster 53b27b8 Merge pull request #138 from tdlrobin/masterzrong 2ae98d8 modify CCFileUtils, export getFileDataremotes/origin/HEAD -&gt; origin/masterremotes/origin/add_build_script d4a8c4f Merge branch ‘master’ into add_build_scriptremotes/origin/devel 752bb84 Merge pull request #158 from Gwill/develremotes/origin/devel_qt51 62208f1 update .gitignoreremotes/origin/master 53b27b8 Merge pull request #138 from tdlrobin/masterremotes/origin/zrong 2ae98d8 modify CCFileUtils, export getFileData删除远程分支： 1$ git push --delete origin devel To git@github.com:zrong/quick-cocos2d-x.git [deleted] devel重命名本地分支： 1 1git branch -m devel develop 推送本地分支： $ git push origin developCounting objects: 92, done.Delta compression using up to 4 threads.Compressing objects: 100% (48/48), done.Writing objects: 100% (58/58), 1.38 MiB, done.Total 58 (delta 34), reused 12 (delta 5)To git@github.com:zrong/quick-cocos2d-x.git [new branch] develop -&gt; develop然而，在 github 上操作的时候，我在删除远程分支时碰到这个错误： $ git push –delete origin develremote: error: refusing to delete the current branch: refs/heads/develTo git@github.com:zrong/quick-cocos2d-x.git ! [remote rejected] devel (deletion of the current branch prohibited)error: failed to push some refs to &#39;git@github.com:zrong/quick-cocos2d-x.git’这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作： 进入 github 中该项目的 Settings 页面；设置 Default Branch 为其他的分支（例如 master）；重新执行删除远程分支命令。把本地tag推送到远程1git push –tags获取远程tag1git fetch origin tag 保存当前修改在缓存中，不可见 1git stash save &quot;worker&quot; 把当前保存在缓存的显示出来，可见 1git stash pop Git-命令行-使用 Tag 标记你的代码参考https://blog.csdn.net/qq_32452623/article/details/73949509 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376951885068a0ac7d81c3a64912b35a59b58a1d926b000 命令git push origin v0.0.1 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d v0.0.1可以删除一个本地标签； 命令git push origin :refs/tags/v0.0.1可以删除一个远程标签。 同步remote branch to local1git push -p 对单次提交的每个文件都添加注释可以单独add/commit，然后最后一起push。 如有两个文件A.md和B.md需要push， 可以如下操作： 12345git add A.mdgit commit -m &quot;add A&quot;git add B.mdgit commit -m &quot;add B&quot;git push..... git squash `Git进阶命令讲解：squash,fixup,stash2014-05-21 GitHub不完全装B指南 @董林 希望我讲一下这三个命令，我看了一下，这三个命令虽然平时用得较少，但是在特定的情况下还是非常有用的，所以我就详细讲解一下。 注意：下面的内容可能有点难，大家要集中精力了。 一、squash squash准确来说并不是一个命令，而是rebase命令的一个功能。squash的作用很简单——合并多个commit。 来看用法： git rebase -i HEAD~5-i的意思是使用“交互式”的修改方法。加了这个参数之后，Git会把所有commit列出来，让你进行一些修改，修改完成之后会根据你的修改来rebase。HEAD-5的意思是只修改最近的5个commit。 运行完这条命令之后，会进入一个编辑界面，大概是这样的： pick awe Add sthpick add Have a restpick xxc Wowpick cxz Yeahpick dsa Finish it可以看到一共有5行，这就是最近的5个commit以及它们的信息。 假设我们现在想把它们合并成一个commit，要怎么做呢？直接看例子： pick awe Add sthsquash add Have a restsquash xxc Wowsquash cxz Yeahsquash dsa Finish it 我们把后4个commit的pick都改成了squash，修改完成之后保存退出，Git就会继续执行rebase命令了。执行完可以看一下结果，最后的4条commit都消失了，它们都被合并到了倒数第5条中。 现在大家应该理解了，squash的作用就是把当前commit向前合并，一直合并到pick为止。 rebase完成之后大家可以看一下最后一个commit的信息，里面会包含rebase之前最后5条的所有commit信息，也就是诸如“Add sth Have a rest Wow Yeah Finish it”这些东西。 二、fixup fixup和squash非常类似，把pick修改成fixup，同样会向前合并到pick，唯一的区别就是，fixup会忽略当前commit的信息，只会应用修改。 怎么理解呢？还用上面的例子说，假设我们使用fixup代替squash： pick awe Add sthfixup add Have a restfixup xxc Wowfixup cxz Yeahfixup dsa Finish it 保存退出之后，等Git执行完rebase我们查看一下最后一条commit的信息，会发现里面只有“Add sth”，另外四条commit的信息比如“Have a rest”都没有了。 三、stash stash是一条Git命令，作用非常简单——保存当前状态。 假设我们现在正在进行工作，修改了一些文件，添加了一些文件。这时我们突然想切换到另一个分支工作，但是又不想commit当前的修改（可能因为它们还不能运行），那该怎么办呢？答案就是stash。 来看命令——git stash 执行完命令之后，Git会把当前的状态保存，同时清理当前目录。我们可以运行一下 git status，会发现当前目录没有任何修改。这时我们就可以放心地切换分支工作了。 等其他工作结束，想继续之前的工作时，可以运行 git stash apply，Git会把保存的状态复原。 stash可以运行多次，会保存多个状态，可以运行 git stash list 来查看所有状态。运行 git stash apply 会默认复原到最近一次保存的状态，如果想指定复原状态可以使用 git stash apply stash@{2} ，这条命令会复原到 stash@{0} 状态。 运行 apply 之后，被复原的状态并不会自动删除，仍然在 stash list 当中。可以运行 git stash drop stash@{0} 来删除 stash@{0} 状态，或者使用 git stash pop 命令来代替 git stash apply 命令，这样复原之后会自动删除被复原状态。 如果 apply 的时候出现冲突（因为你 stash 之后对文件进行了修改），那么需要手动解决冲突。 最后需要注意一点：stash 复原的时候默认不复原 staged 文件，也就是说如果你运行过 add 命令，使用 git status 查看的话文件应当处于 staged 状态，但是如果你 stash 并复原再看，那个文件的状态又变回 unstaged 了。解决办法就是运行 git stash apply 命令时加上 –index 参数：git stash apply –index，这样就可以完全恢复到 stash 之前的状态。 1234修改branch 的名字 git branch -M oldbranch newbranch123456789101112131415161718192021222324252627282930313233git stash 可用来暂存当前正在进行的工作， 比如想pull 最新代码， 又不想加新commit， 或者另外一种情况，为了fix 一个紧急的bug, 先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。基础命令：$git stash$do some work$git stash pop进阶：git stash save &quot;work in progress for foo feature&quot;当你多次使用’git stash’命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，’git stash list’ 命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用’git stash apply stash@&#123;1&#125;’就可以将你指定版本号为stash@&#123;1&#125;的工作取出来，当你将所有的栈都应用回来的时候，可以使用’git stash clear’来将栈清空。git stash # save uncommitted changes# pull, edit, etc.git stash list # list stashed changes in this gitgit show stash@&#123;0&#125; # see the last stash git stash pop # apply last stash and remove it from the listgit stash --help # for more infogit checkout bbbgit rebase master // 把master的代码弄到bbb上(前提条件是文件不冲突，tree进行改变)git checkout --theirs xxx 把xxx 分支的内容放到bbb上git checkout --ours xxx 类似 git删除某个commit1234567891011121314151.git log 获取commit信息 2.git rebase -i (commit-id) commit-id 为要删除的commit的下一个commit号 3.编辑文件，将要删除的commit之前的单词改为drop 4.保存文件退出大功告成 5.git log查看git push origin master –force```i使用--amend 修改 author git commit –amend –author=‘xxx &#x78;&#x78;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#120;&#120;&#120;` https://blog.csdn.net/mocoe/article/details/84344411 https://www.jianshu.com/p/5b3166c855b2 // 把另一个分支structure2的代码merge 到newbr 上，不包括commitgit checkout mastergit checout -b newbrgit merge —squash —no-commit structure2git add vendorgit commit -m “add vendor”git add .git commit -a -m “commit message”","categories":[{"name":"git","slug":"git","permalink":"https://upengs.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://upengs.github.io/tags/git/"}]},{"title":"linux基本命令","slug":"linux-cmd","date":"2019-02-26T14:02:28.000Z","updated":"2019-07-26T06:56:54.022Z","comments":true,"path":"2019/02/26/linux-cmd/","link":"","permalink":"https://upengs.github.io/2019/02/26/linux-cmd/","excerpt":"","text":"ps -ef |grep {fillter}kill -9 {pid}mkdir -p roles/{common,install}/{handlers,files,meta,tasks,templates,varsss -tunlp|grep 7777ss -alnp |grep 7777netstat -tunlp|grep 777netstat -alnp|grep 7777 lsof -i tcp:777chmodu 代表用户.g 代表用户组.o 代表其他.a 代表所有. 这意味着chmod u+x somefile 只授予这个文件的所属者执行的权限而 chmod +x somefile 和 chmod a+x somefile 是一样的 // 实现免密登陆ssh-copy-id root@hostip 压缩文件tar -czvf wisecloud-ingress-controller.gz ./wisecloud-ingress-controller 解压文件tar -zxvf wisecloud-ingress-controller.gz -o ./ docker run –rm -it golang:1.10 sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990grep -A 50grep -B 50``kcc get pod |grep orchestration | awk &apos;&#123;print $1&#125;&apos;screen 使用screen 执行逻辑screen -list screen -r screen -r 30719.pts-4.dev-10There is a screen on: 30719.pts-4.dev-10 (Attached)There is no screen to be resumed matching 30719.pts-4.dev-10.[root@dev-10 ~]# screen -r 30719.pts-4.dev-netstat -an|wc -l wc 统计行号kubectl get -o template node/dev-9 --template=&#123;&#123;.spec&#125;&#125;linux 部分快捷键1. Tab这是你不能没有的 Linux 快捷键。它将节省你 Linux 命令行中的大量时间。只需要输入一个命令，文件名，目录名甚至是命令选项的开头，并敲击 tab 键。 它将自动完成你输入的内容，或为你显示全部可能的结果。如果你只记一个快捷键，这将是必选的一个。2. Ctrl + C这些是为了在终端上中断命令或进程该按的键。它将立刻终止运行的程序。如果你想要停止使用一个正在后台运行的程序，只需按下这对组合键。3. Ctrl + Z该快捷键将正在运行的程序送到后台。 通常，你可以在使用 &amp; 选项运行程序前之完成该操作， 但是如果你忘记使用选项运行程序，就使用这对组合键。4. Ctrl + D这对键盘快捷键将使你退出当前终端。如果你使用 SSH 连接，它将会关闭。 如果你直接使用一个终端，该应用将会立刻关闭。把它当成“退出”命令。5. Ctrl + L你怎么清空你的终端屏幕？我猜是用 clear 命令。你可以使用 Ctrl+L 清空终端，代替输入 C-L-E-A-R。得心应手，不是吗？6. Ctrl + A该快捷键将移动光标到所在行首。假设你在终端输入了一个很长的命令或路径，并且你想要回到它的开头， 使用方向键移动光标将花费大量时间。注意你无法使用鼠标移动光标到行首。这是 Ctrl+A 节省时间的地方。7. Ctrl + E这对快捷键与 Ctrl+A 相反。 Ctrl+A 送光标到行首，反之 Ctrl+E 移动光标到行尾。8. Ctrl + U输入了错误的命令？ 代替用退格键来丢弃当前命令，使用 Linux 终端中的 Ctrl+U 快捷键。 该快捷键会擦除从当前光标位置到行首的全部内容。9. Ctrl + K这对和 Ctrl+U 快捷键有点像。 唯一的不同在于不是行首，它擦除的是从当前光标位置到行尾的全部内容。10. Ctrl + W你刚才了解了擦除到行首和行尾的文本。 但如果你只需要删除一个单词呢？使用 Ctrl+W 快捷键。使用 Ctrl+W 快捷键，你可以擦除光标位置前的单词。 如果光标在一个单词本身上，它将擦除从光标位置到词首的全部字母。最好的方法是用它移动光标到要删除单词后的一个空格上， 然后使用 Ctrl+W 键盘快捷键。11. Ctrl + Y这将粘贴使用 Ctrl+W，Ctrl+U 和 Ctrl+K 快捷键擦除的文本。 如果你删除了错误的文本或需要在某处使用已擦除的文本，这将派上用场。12. Ctrl + P你可以使用该快捷键来查看上一个命令。 你可以反复按该键来返回到历史命令。 在很多终端里，使用 PgUp 键来实现相同的功能。13. Ctrl + N你可以结合 Ctrl+P 使用该快捷键。Ctrl+N 显示下一个命令。 如果使用 Ctrl+P 查看上一条命令，你可以使用 Ctrl+N 来回导航。 许多终端都把此快捷键映射到 PgDn 键。14. Ctrl + R你可以使用该快捷键来搜索历史命令。 通过m命令。讲光标放在你要移动的行，输入:m +1向下移动一行，输入:m -2向上移动一行。 面的命令设置最低空闲内存，立即生效，但系统重启会失效。永久生效则要写到配置文件 1/etc/sysctl.conf 1sysctl set vm.min_free_kbytes=1024000 ESC + f – 向右移动一个单词，MAC下建议用ALT + →Esc + . – 获取上一条命令的最后部分（空格分隔）ESC + b – 向左移动一个单词，MAC下建议用ALT + ←","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://upengs.github.io/tags/linux/"}]},{"title":"helm","slug":"helm","date":"2019-02-26T10:42:41.000Z","updated":"2019-07-02T08:22:01.783Z","comments":true,"path":"2019/02/26/helm/","link":"","permalink":"https://upengs.github.io/2019/02/26/helm/","excerpt":"","text":"helm 注意事项helm install chats 与repo 有关 helm 获取删除chats release 只与config 有关 helm repo add 可以 重复，第二次添加类似updatehelm create wphelm package wp –debug 启动helm repo serve1nohup ./helm serve --address 0.0.0.0:8879 &amp; 通过harbor 启动helm repo1sudo ./install.sh --with-clair --with-chartmuseum 添加harbor repo 需要密码1helm repo add --username=admin --password=Passw0rd myrepo https://xx.xx.xx.xx/chartrepo 添加私有特定仓库 公有的无需密码1helm repo add --username=admin --password=Passw0rd myrepo https://xx.xx.xx.xx/chartrepo/myproject","categories":[{"name":"helm","slug":"helm","permalink":"https://upengs.github.io/categories/helm/"},{"name":"kubernetes","slug":"helm/kubernetes","permalink":"https://upengs.github.io/categories/helm/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://upengs.github.io/tags/kubernetes/"},{"name":"helm","slug":"helm","permalink":"https://upengs.github.io/tags/helm/"}]},{"title":"容器化日志收集方案-EFK","slug":"fluentd","date":"2019-02-26T04:12:53.000Z","updated":"2019-07-02T13:19:11.209Z","comments":true,"path":"2019/02/26/fluentd/","link":"","permalink":"https://upengs.github.io/2019/02/26/fluentd/","excerpt":"","text":"本文将描述如何使用elasticsearch、fluentd 、kibana构建容器化日志收集系统 介绍：elasticsearch： 一个分布式的实时文档存储，每个字段 可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 fluentd:是日志收集系统，通过丰富的插件，可以收集来自于各种系统或应用的日志，然后根据用户定义将日志做分类处理。 kibana:是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。 Kafka:是分布式的、可分区的、可复制的消息系统。它提供了普通消息系统的功能，但具有自己独特的设计 Kafka将消息以topic为单位进行归纳。将向Kafka topic发布消息的程序成为producers.将预订topics并消费消息的程序成为consumer. 如何安装 安装kafka+zookeeper 参考：https://hub.docker.com/r/wurstmeister/kafka/ 安装elasticsearch+kibana: 12docker run -d -v \"$PWD/esdata\":/usr/share/elasticsearch/data -p 9200:9200 elasticsearchdocker run --name kibana -e ELASTICSEARCH_URL=http://127.0.0.1:9200 -p 5601:5601 -d kibana 安装fluentd 1、自定义fluentd的Dockerfile12345678910111213141516171819FROM fluent/fluentd:v1.2# below RUN includes plugin as examples elasticsearch is not required# you may customize including plugins as you wishRUN apk add --update --virtual .build-deps \\ sudo \\ build-base \\ ruby-dev \\ tzdata \\ &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \\ &amp;&amp; sudo gem install fluent-plugin-elasticsearch \\ &amp;&amp; sudo gem install fluent-plugin-kafka \\ &amp;&amp; sudo gem sources --clear-all \\ &amp;&amp; apk del .build-deps \\ &amp;&amp; rm -rf /var/cache/apk/* \\ /home/fluent/.gem/ruby/2.3.0/cache/*.gemENTRYPOINT [&quot;fluentd&quot;, &quot;-c&quot;, &quot;/fluentd/etc/fluent.conf&quot;, &quot;-p&quot;, &quot;/fluentd/plugins&quot;] 2、编写fluent.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;system&gt; rpc_endpoint 127.0.0.1:24444&lt;/system&gt;&lt;source&gt; @type forward @id forward_input&lt;/source&gt;&lt;source&gt; @type tail #### tail方式采集日志 #format none format /^(?&lt;all&gt;.*)$/ path /log/log.txt pos_file /log/pos_file/httpd-access.log.pos tag log.tag&lt;/source&gt;&lt;match log.**&gt; @type copy &lt;store&gt; @type elasticsearch hosts localhost:9200 type_name elasticsearch_fluentd include_tag_key true tag_key log_name flush_interval 10s # for testing logstash_format true logstash_prefix logstash &lt;/store&gt; &lt;store&gt; @type kafka brokers localhost:9092 #zookeeper localhost:2181 default_topic fluent_kafka #刷新间隔 flush_interval 30 ack_timeout 2000 output_data_type attr:all &lt;/store&gt;&lt;/match&gt;&lt;source&gt; @type monitor_agent @id monitor_agent_input port 24220&lt;/source&gt;&lt;match debug.**&gt; @type stdout&lt;/match&gt; 3、构建fluentd image:1docker build -t fluentd:test -f Dockerfile . 4、启动fluentd1docker run -it --rm --name fluent_test -v $(pwd)/log/:/log/ -v $(pwd)/:/fluentd/etc/ fluentd:test ==说明== 配置fluentd的RPC 为了重新加载fluentd.conf文件参考：https://docs.fluentd.org/v1.0/articles/rpc 123&lt;system&gt; rpc_endpoint 127.0.0.1:24444&lt;/system&gt; 测试1增加这个文件的日志 echo test &gt; $(pwd)/log/log.txt 在kibana中进行日志查看： 修改fluent.conf 12tag_key log_name 修改为tag_key log_name_key执行curl http://127.0.0.1:24444/api/config.reload 即可以重新加载fluent.conf配置文件，使其生效继续向log.txt写入日志 fluentd向kafka写入日志 进入kafka的container中 执行 1bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic fluent_kafka --from-beginning 附上kafka基本命令 1234567891011121314创建topic 这里创建的topic为：bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic 查看topicking bin/kafka-topics.sh --list --zookeeper zookeeper:2181挂起生产者：producerbin/kafka-console-producer.sh --broker-list localhost:9092 --topic test挂起之后，就可以输入信息：test挂起消费者： consumer:bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning在consulmer就可以看到生产出来的：test 至此完成了基本的elk 和fluent+kafka+zookeeper的日志系统 在kubernetes中使用DaemonSet 来获取主机日志或docker container日志 参考：https://docs.fluentd.org/v1.0/articles/quickstart ​ https://www.elastic.co/products","categories":[],"tags":[{"name":"log","slug":"log","permalink":"https://upengs.github.io/tags/log/"}]},{"title":"dragonfly 之 p2p 镜像分发","slug":"dragonfly","date":"2019-02-26T01:07:21.000Z","updated":"2019-02-26T04:09:18.399Z","comments":true,"path":"2019/02/26/dragonfly/","link":"","permalink":"https://upengs.github.io/2019/02/26/dragonfly/","excerpt":"","text":"支持https harbor，公有或私有仓库支持push image 什么是dragonfly Dragonfly 是一款基于 P2P 的智能镜像和文件分发工具。它旨在提高文件传输的效率和速率，最大限度地利用网络带宽，尤其是在分发大量数据时，例如应用分发、缓存分发、日志分发和镜像分发。 在阿里巴巴，Dragonfly 每个月会被调用 20 亿次，分发的数据量高达 3.4PB。Dragonfly 已成为阿里巴巴基础设施中的重要一环。 尽管容器技术大部分时候简化了运维工作，但是它也带来了一些挑战：例如镜像分发的效率问题，尤其是必须在多个主机上复制镜像分发时。 Dragonfly 在这种场景下能够完美支持 Docker 和 PouchContainer。它也兼容其他格式的容器。相比原生方式，它能将容器分发速度提高 57 倍，并让 Registry 网络出口流量降低 99.5%。 Dragonfly 能让所有类型的文件、镜像或数据分发变得简单而经济。 Dragonfly 有何优势（具备以下特性）？ 基于 P2P 的文件分发：通过利用 P2P 技术进行文件传输，它能最大限度地利用每个对等节点（Peer）的带宽资源，以提高下载效率，并节省大量跨机房带宽，尤其是昂贵的跨境带宽。 非侵入式支持所有类型的容器技术：Dragonfly 可无缝支持多种容器用于分发镜像。 机器级别的限速：除了像许多其他下载工具（例如 wget 和 curl）那样的针对当前下载任务的限速之外，Dragonfly 还支持针对整个机器的限速。 被动式 CDN：这种 CDN 机制可防止重复远程下载。 高度一致性：Dragonfly 可确保所有下载的文件是一致的，即使用户不提供任何检查代码（MD5）。 磁盘保护和高效 IO：预检磁盘空间、延迟同步、以最佳顺序写文件分块、隔离网络-读/磁盘-写等等。 高性能：SuperNode 是完全闭环的，意味着它不依赖任何数据库或分布式缓存，能够以极高性能处理请求。 自动隔离异常：Dragonfly 会自动隔离异常节点（对等节点或 SuperNode）来提高下载稳定性。 对文件源无压力：一般只有少数几个 SuperNode 会从源下载文件。 支持标准 HTTP 头文件：支持通过 HTTP 头文件提交鉴权信息。 有效的 Registry 鉴权并发控制：减少对 Registry 鉴权服务的压力。 简单易用：仅需极少的配置。 dragonfly原理Dragonfly 下载普通文件和下载容器镜像的工作原理略有不同。 下载普通文件SuperNode 充当 CDN，并负责调度对等节点（Peer）之间的文件分块传输。dfget 是 P2P 客户端，也称为“Peer”（对等节点），主要用于下载和共享文件分块。 下载镜像文件Registry 类似于文件服务器。dfget proxy 也称为 dfdaemon，会拦截来自 docker pull 或 docker push 的 HTTP 请求，然后使用 dfget 来处理那些跟镜像分层相关的请求。 下载文件分块每个文件会被分成多个分块，并在对等节点之间传输。一个对等节点就是一个 P2P 客户端。SuperNode 会判断本地是否存在对应的文件。如果不存在，则会将其从文件服务器下载到 SuperNode。 dragonfly部署（参考dragonfly官网）https://d7y.io/zh-cn/ dragonfly https的harbordragonfly 常见问题 https://github.com/dragonflyoss/Dragonfly/blob/master/FAQ.md 目的：启用 docker PROXY 让dragonfly 支持https 1、部署https harborhttps://github.com/goharbor/harbor/blob/master/docs/configure_https.md 2、部署docker_proxypull images pull_images.sh123456789101112131415#!/bin/shdocker_registry_proxy=&quot;dockerhubwp/docker_proxy_nginx:latest&quot;supernode=&quot;registry.cn-hangzhou.aliyuncs.com/alidragonfly/supernode:0.2.0&quot;dfclient=&quot;dockerhubwp/dfclient:latest&quot;images=&quot;$&#123;docker_registry_proxy&#125; $&#123;supernode&#125; $&#123;dfclient&#125;&quot;function pullImage()&#123; for image in $&#123;images&#125;; do echo -e &quot;pull image ======&gt;$&#123;image&#125;&quot; docker pull $&#123;image&#125; done&#125;pullImage docker_proxy.sh 1234567891011121314151617181920212223242526272829303132333435363738#! /bin/sh# Separate deployment docker_proxy# dfdaemon and docker registry map# example x.x.xregistry=&quot;harbor域名&quot;containername=docker_registry_proxy# 你需要配置的dns 服务器 (如：dnsmasq) DNS_SERVER=&quot;dns-server&quot;docker_registry_proxy=&quot;dockerhubwp/docker_proxy_nginx:latest&quot;# get localhost ipipaddr=$(ip addr | awk &apos;/^[0-9]+: / &#123;&#125;; /inet.*global/ &#123;print gensub(/(.*)\\/(.*)/, &quot;\\\\1&quot;, &quot;g&quot;, $2)&#125;&apos;)localhostIp=$(echo $&#123;ipaddr&#125; | cut -d &quot; &quot; -f 1)function changeDockerProxy() &#123; mkdir -p /etc/systemd/system/docker.service.d cat &lt;&lt;EOD &gt;/etc/systemd/system/docker.service.d/http-proxy.conf[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:3128/&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:3128/&quot;EOD&#125;function dockerDockerProxyRun() &#123; if [[ 0 != $(docker ps -a | grep $&#123;containername&#125; | wc -l) ]]; then docker rm -f $&#123;containername&#125; fi docker run --restart=always --privileged=true --name $&#123;containername&#125; -d -p 0.0.0.0:3128:3128 -v /etc/docker_proxy_nginx/docker_mirror_certs:/ca -v /var/log/docker_proxy_nginx:/var/log/nginx/ -e DRAGONFLY_REGISTRIES=&quot;$&#123;registry&#125;,http://$&#123;localhostIp&#125;:65001&quot; -e REGISTRIES=&quot;$&#123;registry&#125;&quot; -e DNS_SERVER=$&#123;DNS_SERVER&#125; $&#123;docker_registry_proxy&#125;&#125;changeDockerProxysystemctl daemon-reloadsystemctl restart dockerdockerDockerProxyRun 3、部署dragonfly部署Supernodesupernode.sh1234567891011121314#!/bin/sh# Separate deployment supernodesupernode=&quot;registry.cn-hangzhou.aliyuncs.com/alidragonfly/supernode:0.2.0&quot;containername=supernodefunction superNode() &#123; if [[ 0 != $(docker ps -a | grep $&#123;containername&#125; | wc -l) ]]; then docker rm -f $&#123;containername&#125; fi docker run --name $&#123;containername&#125; --restart=always -d -p 8001:8001 -p 8002:8002 $&#123;supernode&#125;&#125;superNode 部署dfclientdfclient.sh 12345678910111213141516171819202122232425262728293031#!/bin/sh# Separate deployment docker_proxydfclient=&quot;dockerhubwp/dfclient:latest&quot;#harbor 地址dfdaemon_registry=&quot;https://x.x.x&quot;containername=dfclient# supernode ips example (10.0.0.160,10.0.0.162)supernodes=&quot;supernodeip&quot;ipaddr=$(ip addr | awk &apos;/^[0-9]+: / &#123;&#125;; /inet.*global/ &#123;print gensub(/(.*)\\/(.*)/, &quot;\\\\1&quot;, &quot;g&quot;, $2)&#125;&apos;)localhostIp=$(echo $&#123;ipaddr&#125; | cut -d &quot; &quot; -f 1)cat &lt;&lt;EOD &gt;/etc/dragonfly.conf[node]address=$&#123;supernodes&#125;EODfunction startDfClient() &#123; if [[ 0 != $(docker ps -a | grep $&#123;containername&#125; | wc -l) ]]; then docker rm -f $&#123;containername&#125; fi docker run --name $&#123;containername&#125; --restart=always -d -p 65001:65001 -v /root/.small-dragonfly:/root/.small-dragonfly -v /etc/dragonfly.conf:/etc/dragonfly.conf -e dfdaemon_registry=$&#123;dfdaemon_registry&#125; -e localhostIp=$&#123;localhostIp&#125; $&#123;dfclient&#125;&#125;startDfClient 最后 trust.sh1234567#!/bin/sh# trust cacurl http://127.0.0.1:3128/ca.crt &gt;/etc/pki/ca-trust/source/anchors/docker_proxy_nginx.crtupdate-ca-trust 1docker pull x.x.x/library/nginx:latest 参考： https://d7y.io/zh-cn/ https://github.com/goharbor/harbor/ https://github.com/rpardini/docker-registry-proxy https://github.com/chobits/ngx_http_proxy_connect_module","categories":[],"tags":[]},{"title":"搭建nginx-https","slug":"nginx-https","date":"2019-02-25T04:24:07.000Z","updated":"2019-06-23T14:58:32.905Z","comments":true,"path":"2019/02/25/nginx-https/","link":"","permalink":"https://upengs.github.io/2019/02/25/nginx-https/","excerpt":"","text":"nginx httpsdefalut.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 upstream www.aaa.com.38240.r1.up &#123; server 127.0.0.1:8443 weight=1 max_fails=1 fail_timeout=10s; &#125;server &#123; listen 38240; server_name registry.wise2c.com; access_log /var/log/nginx/host.access.log main; error_log /var/log/nginx/host_error.log; # for support ssl ssl on; ssl_certificate /etc/nginx/registry.wise2c.com.crt; ssl_certificate_key /etc/nginx/registry.wise2c.com.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; proxy_headers_hash_max_size 51200; proxy_headers_hash_bucket_size 6400; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header Upgrade &quot;TLS/1.2, HTTP/1.1&quot;; add_header Connection &quot;Upgrade&quot;; add_header PPP https://$host:$server_port$uri/; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; proxy_pass http://www.aaa.com.38240.r1.up/; proxy_connect_timeout 2s; proxy_redirect http:// $scheme://; &#125; &#125; 1234567891011121314151617https http端口(88)相同 域名不相同 访问http://www.xx.com:88 400 访问https://www.xxx.com:88 200端口相同 域名相同 只有https的存在问题nginx log2019/02/25 08:10:46 [warn] 1#1: conflicting server name &quot;registry.wise2c.com&quot; on 0.0.0.0:38240, ignorednginx: [warn] conflicting server name &quot;registry.wise2c.com&quot; on 0.0.0.0:38240, ignored端口不相同 域名相同 200 Nginx环境下http和https可同时访问方法123456789101112131415server &#123;listen 80 default backlog=2048;listen 443 ssl;server_name x.x.x;root /var/www/html;ssl_certificate /usr/local/Tengine/sslcrt/domain.crt;ssl_certificate_key /usr/local/Tengine/sslcrt/domain.Key; location / &#123; proxy_pass http://www.aaa.com.38240.r1.up/; proxy_connect_timeout 2s; proxy_redirect http:// $scheme://; &#125;&#125; 123456789101112131415161718https://www.ixsystems.com/community/threads/how-to-owncloud-using-nginx-php-fpm-and-mysql.17786/page-78#post-395092过添加client_body_in_file_only clean 找到解决方案; client_body_buffer_size 32K; #set max upload size client_max_body_size 4000M; add_header X-Xss-Protection“1; mode = block”总是; add_header X-Content-Type-Options“nosniff”总是; add_header Strict-Transport-Security“max-age = 2592000; includeSubdomains”总是; add_header X-Frame-Options“SAMEORIGIN”总是; proxy_hide_header X-Powered-By; add_header&apos;Referrer-Policy&apos;&apos;no-referrer&apos;; add_header Content-Security-Policy“frame-ancestors mydomain.eu;”; dragonfly docker proxy branch fix-md2 123456789101112131415161718server &#123; listen 443 ssl; server_name localhost; # 上面生成的自签名证书 ssl_certificate /tmp/ssl/server.crt; ssl_certificate_key /tmp/ssl/server.key; ssl_session_timeout 5m; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 后端服务 proxy_pass http://localhost:8080; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://upengs.github.io/tags/nginx/"}]},{"title":"docker 版kafka集群搭建","slug":"kafka","date":"2019-02-25T02:27:45.000Z","updated":"2019-07-02T12:51:08.353Z","comments":true,"path":"2019/02/25/kafka/","link":"","permalink":"https://upengs.github.io/2019/02/25/kafka/","excerpt":"","text":"kafka 集群搭建参考:https://hub.docker.com/r/wurstmeister/kafka/tags docker-compose.yaml123456789101112131415version: &apos;2&apos;services: zookeeper: image: wurstmeister/zookeeper ports: - &quot;2181:2181&quot; kafka: image: wurstmeister/kafka ports: - &quot;9092&quot; environment: KAFKA_ADVERTISED_HOST_NAME: 10.0.0.159 #需要改成宿主ip KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 volumes: - /var/run/docker.sock:/var/run/docker.sock 启动kafka12docker-compose up -ddocker-compose scale kafka=3","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://upengs.github.io/tags/docker/"},{"name":"kafka","slug":"kafka","permalink":"https://upengs.github.io/tags/kafka/"}]},{"title":"Use Hexo","slug":"hello-world","date":"2019-02-24T09:50:38.049Z","updated":"2019-02-25T02:34:01.282Z","comments":true,"path":"2019/02/24/hello-world/","link":"","permalink":"https://upengs.github.io/2019/02/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://upengs.github.io/tags/hexo/"}]}]}